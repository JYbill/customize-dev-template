services: # 容器列表
  hbbs: # 镜像名
    container_name: hbbs # 容器名
    image: rustdesk/rustdesk-server:latest # 对应镜像与其版本
    pull_policy: always # 每次启动时拉取最新镜像
    
    
    volumes: # 挂载卷轴
      - /home/ubuntu/docker/rustdesk:/root
      # 设置容器对挂载卷轴的权限(即对宿主机的操作权限)
      - /data:/data:rw # 容器只有读写权限
      - /etc/localtime:/etc/localtime:ro # 只有只读权限
      # 读取环境变量DOCKER_VOLUME_DIRECTORY，如果不存在则为"."即"./volumes/etcd:/etcd"
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/etcd:/etcd
      
    
    network_mode: "host" # 网络
    depends_on: # 依赖于hbbr容器启动后，才启动hbbs
      - hbbr
      
    # 允许访问宿主机所有权限。等同于宿主机root权限
    privileged: true
    # 在原有容器权限基础上，添加所有的Linux（能力），比如 NET_ADMIN、SYS_TIME 等。容器获得了更多特权，但仍然<宿主机的root
    cap_add:
      - ALL
      - SYS_ADMIN # 一大堆系统管理类操作，但范围小于ALL
    # 容器与宿主机共享同一个进程命名空间（PID namespace）。这样容器内可以看到宿主机上的所有进程，并且可以对它们进行操作（如 ps、kill）。常用于需要监控或管理宿主机进程的场景（⚠️ 有风险）
    pid: host

    # 在容器里加一个很小的init PID:1进程，回收僵尸进程、正确转发信号、优雅退出
    init: true
    
    # 重启规则
    # always：总是重启，不推荐
    # unless-stopped：崩溃或退出停止了，则会自动重启；而手动退出则不会👍
    # on-failure: n：发生错误后自动最多重启n次
    restart: unless-stopped

    # 最长优雅停止时长，默认会等待10s结束
    stop_grace_period: 10s
    
    # 从docker.env读取环境变量
    env_file:
      - docker.env
    environment:
      - TZ=Asia/Shanghai
    
    # 一个网络端口部署3个副本实例，需要配合docker swarm启动
    deploy:
      replicas: 3

# 设置网络
# 访问：http://my_network:port
networks:
  default:
    name: my_network