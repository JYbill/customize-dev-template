{
  // 在编辑了tsconfig文件保存后，编辑器会根据tsconfig.json的配置重新生成文件，不过这个需要编辑器支持
  // "compileOnSave": true,
  // ⚠️ 继承来的同名配置会覆盖当前文件定义的配置(typescript 3.2+)
  // "extends": "",
  "compilerOptions": {
    // 指定编译之后的版本目标，默认target为ES3，ESNEXT为最新规范
    "target": "ES2022",
    // 使用的模块标准，target默认跟随target，如target：ES6，module默认为ES6
    "module": "NodeNext",
    // 用来指定编译文件的根目录，编译器会在根目录查找入口文件
    "rootDir": "./src",
    // 用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹
    "outDir": "./dist",

    // es模块交互，推荐开启，可以让ESModule与require进行交互使用，特别是有些第三方库是commonJS导出的
    "esModuleInterop": true,

    // 导入文件采用大小写一致，false允许忽略大小写
    "forceConsistentCasingInFileNames": true,

    // 跳过第三方库检查的类型检查
    "skipLibCheck": true,

    // 包含一组内建JS接口的类型定义，如"DOM"...，默认包括target相匹配的api类型定义
    "lib": ["ESNext"],

    // "allowJs": false, // 默认，false：不允许编写js
    // checkJs：值为 true 或 false，用来指定是否检查和报告 JS 文件中的错误，默认是 false。
    // "checkJs": false,
    // typing跟路径, 默认情况node_modules/@types都是可见的，除特例
    // "typeRoots": ["./"]

    // 指定jsx代码用于的开发环境
    // "preserve": 保留原始jsx后续用babel转更好
    // "react"： 转成react编译后对应的js代码，如<div>哈哈哈哈</div> => createElement("div", {}, [哈哈哈哈])
    "jsx": "preserve",

    // 指定生成目标为react JSX时，使用的JSX工厂函数
    // "jsxFactory": "React.createElement",
    // 用来指定是否在编译的时候生成响应的".d.ts"声明文件。如果设为 true，编译每个 ts 文件之后会生成一个 js 文件和一个声明文件
    "declaration": false,
    // 是否为声明文件.d.ts生成.map文件
    "declarationMap": true,
    // 是否允许导入json模块，默认：false
    "resolveJsonModule": true,
    // 为 true 时，它会隐式地将 catch 中的任何变量设置为 unknown 而不是 any
    // "useUnknownInCatchVariables": false,

    // 检测到一定会执行return代码后，后面如果还有代码会报错
    "allowUnreachableCode": true,

    // 使用`.`访问存在的属性object.params，使用object["name"]访问未知的选项
    "noPropertyAccessFromIndexSignature": true,

    // 允许模块所有导出时，无需使用`* as`的语法糖
    // 例子：原本需要import * as React from "react";
    // 为true时，import React from "react";
    "allowSyntheticDefaultImports": true,

    // 用于指定将输出文件合并为一个文件，它的值为一个文件路径名, 只有设置 module 的值为 amd 和 system 模块时才支持这个配置
    // "outFile": "./dist/main.js"
    // 是否将编译后的文件中的注释删掉, 默认false, 除了/!*开头的版权信息
    "removeComments": true,
    // 不生成变编译文件
    // "noEmit": false,

    // 指定是否引入tslib里的辅助工具函数， 默认false
    // 形如babel里的`polyfill`，当前环境没有的api，通过polyfill补丁的形式打包进去，从而正常使用
    "importHelpers": true,

    // 是否将每个文件作为单独的模块，默认true，它不可以和`declaration`同时设定
    // "isolatedModules": true,

    // --------------------------  类型检查选项 start --------------------------
    "strict": true, // 严格类型检查模式, 为true开启下面包含的所有检查，默认false
    "noImplicitAny": true, // 不允许type类型为any，包括自动推断为any也会报错
    "alwaysStrict": true, // 并且在编译之后的 JS 文件中加入"use strict"，用来告诉浏览器该 JS 为严格模式
    "strictNullChecks": true, // null和 undefined 值不能赋值给非这两种类型的值，如`const str: string;` 报错
    // 会更彻底地检查函数参数
    /* 
      interface Animal {
        name: string;
      }
      interface Dog extends Animal {
        breeds: Array<string>;
      }
      let getDogName = (dog: Dog) => dog.name;
      let getAnimalName = (animal: Animal) => animal.name;

     getDogName = getAnimalName; // Okay (狗是动物，所以可以变成动物，广范围可以接受窄范围)
     getAnimalName = getDogName; // Okay (默认okay，开启后即bad，动物无法变成狗，窄范围无法接收广范围)
     */
    "strictFunctionTypes": true,
    "strictPropertyInitialization": true, // 确保在构造函数中初始化所有类属性，否则报错，或者可以定义为String | undefined
    "strictBindCallApply": true, // 不正确使用call()、bind() 和 apply() 函数时会报错，如：传参...
    // --------------------------  类型检查选项 end  --------------------------

    // 额外检查
    // 不允许出现未使用的变量
    "noUnusedLocals": false,
    // 不允许出现未使用的变量(范围仅在函数型参和函数内部)
    // "noUnusedParameters": false,
    // 保证所有函数返回值都显示声明return
    "noImplicitReturns": true,
    // switch语句中缺少`break`或`return`关键字，这个编译选项就会生成错误
    "noFallthroughCasesInSwitch": true,
    // 不正确地使用 this 关键字的情况下或在不清楚 this 所指的位置的地方提示错误
    "noImplicitThis": true,

    // 模块查找规则，一般用"node"查找规则
    // node查找规则：const fs = require("fs");
    // "moduleResolution": "node"

    // 基准目录：
    /*
    baseUrl
        ├── ex.ts
        ├── hello
        │   └── world.ts
        └── tsconfig.json

      // 设置之后以当前目录为基准目录
      // 未设置：import { helloWorld } from "./hello/world";
      import { helloWorld } from "hello/world";
      console.log(helloWorld);
    */
    // "baseUrl": "./"

    // 用于设置模块名到基于baseUrl的路径映射的`别名`
    /*
      // 你可以告诉TS文件解析器路径别名，⚠️ 仅起到路径解析，如果使用其他构建工具进行打包，需在再其他构建工具(如：webpack、vite)中也要配置别名，这里只是起到类型检测的作用！
      {
        "compilerOptions": {
          "baseUrl": "src",
          "paths": {
              "app/*": ["app/*"],
              "config/*": ["app/_config/*"],
              "tests/*": ["tests/*"]
          },
      }
    */
    // "paths": {},

    // 在构建时编译器会将这个路径列表中的路径内容都放到一个文件夹中
    // "rootDirs": [],
    // 用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载, 默认所有"**/node_modules/**/@types/*"包都将包含在你的编译过程中
    // "typeRoots": [],
    // 用来指定需要包含的模块，只有在这里列出的模块声明文件才会被加载进来
    // "types": [],
    // 允许从没有默认导出的模块中默认导入
    // "allowSyntheticDefaultImports": false,

    // --------------------------  source map start  --------------------------
    // 源码.ts映射.map文件，便于报错时知道ts文件错误发生的位置信息
    "sourceMap": true
    // 指定调试器应该找到 TypeScript 文件而不是js源文件位置，这个值会被写进 .map 文件里
    // "sourceRoot": ""
    // 指定调试器找到映射文件而非生成文件的位置，指定 map 文件的根路径
    // "mapRoot": ""
    // 用于指定是否进一步将 .ts 文件的内容也包含到输出文件中。
    // "inlineSources": true,
    // --------------------------  source map start  --------------------------

    /* 实验性选项 */
    // 用于指定是否启用实验性的装饰器特性
    // "experimentalDecorators": true,
    // 用于指定是否为装饰器提供元数据支持
    // "emitDecoratorMetadata": true,
  }

  // --------------------------  选择、排除编译文件 start  --------------------------
  // "files": [] // 指定需要编译的ts文件，👎(基本不用)
  // "include": ["src/**/*.ts", "type/*.d.ts"], // ⚠️ 默认：根目录下的所有文件；指定需要编译的ts文件，支持global通配符
  // "exclude": ["type/*.d.ts"] // 从`include`包含的文件中移除指定文件，支持global通配符
  // --------------------------  选择、排除编译文件 end  --------------------------
}
